snippet always  always @ ..
	always @(${1:posedge clk}) begin
	    ${2}
	end
snippet always  always_comb ..
	always_comb begin
	    ${1}
	end
snippet always_comb  always_comb ..
	always_comb begin
	    ${1}
	end
snippet always  always_ff ..
	always_ff @(${1:posedge clk or negedge reset_n})
	    ${2}
	end
snippet always_ff  always_ff ..
	always_ff @(${1:posedge clk or negedge reset_n})
	    ${2}
	end
snippet always  always_latch ..
	always_latch
	    ${1}
	end
snippet always_latch  always_latch ..
	always_latch
	    ${1}
	end
snippet case  case() .. 
	case(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet case  casex() .. 
	casex(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet casex  casex() .. 
	casex(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet case  casez() .. 
	casez(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet casez  casez() .. 
	casez(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet class  class .. endclass
	class ${1:class_name} extends ${2:base_class};
	   ${5}

	   extern function new(${3:args});
	endclass : $1

	//-------------------------------------------------------------------------------------
	function $1::new($3);
		super.new(${4});
	endfunction : new
snippet clocking  clocking .. { .. }
	clocking ${1:name_cb} @(posedge ${2:clock});
	    default input #${3:setup_time} output #${4:hold_time};
	    ${5}
	    // output declarations
	    // input declarations
	endclocking: $1
snippet do  do .. while()
	do begin
	    ${2}
	end while($1);
snippet enum  enum .. { .. }
	typedef enum {${2}
		      } ${1:name_e};
snippet final  final ..
	final begin
	    ${1}
	end
snippet for  for() .. 
	for(${1:int i = 0}; ${2:i <= n}; ${3:i++}) begin
	    ${4}
	end
snippet foreach  foreach(x[i]) ..
	foreach(${1:x}[i]) begin
	    ${2}
	end
snippet forever  forever .. 
	forever begin
	    ${1}
	end
snippet fork  fork .. join
	fork
	    begin
	        ${1}
	    end
	    begin
	
	    end
	join
snippet fork  fork .. join_any
	fork
	    begin
	        ${1}
	    end
	    begin
	
	    end
	join_any
snippet fork  fork .. join_none
	fork
	    begin
	        ${1}
	    end
	    begin
	
	    end
	join_none
snippet function  function .. endfunction
	function ${1:void} ${2:function_name} ($3);
	    ${4}
	endfunction: $2
snippet cover  covergroup .. endgroup
	covergroup ${1:function_name};
	    ${2}
	endgroup: $1
snippet if  if() .. 
	if(${1:condition}) begin
	    ${2}
	end
snippet ife  if() .. else
	if(${1:condition}) begin
	    ${2}
	end
	else begin
	    ${3}
	end
snippet initial  initial ..
	initial begin
	    ${1}
	end
snippet interface  interface .. { .. }
	// transactors that use them
	interface ${1:name_if} (// input wire clk,
			     // input wire reset
			     );
	    timeunit 1ns;
	    timeprecision 100ps;
	
	    ${2}
	    // imports
	    // import pkg::*;
	
	    parameter hold_time = 2;     // timeunit is 1ns
	    parameter setup_time = 2;    // change timing values as per requirement
	
	    // Clocking Blocks
	    // just type clocking and tab to invoke snippet
	
	    // Modports
	    // just type modport and tab to invoke snippet
	
	endinterface: $1
snippet modport  modport .. { .. }
	modport ${1:name_mp}
	    (${2}
	     // clocking clocking_cb,
	     // input input_name,
	     // output output_port,
	     // ....
	     );
snippet module  module .. endmodule
	module ${1:module_name} (/*port details*/);
	    ${2}
	endmodule: $1
snippet once  `ifndef XXX; `define XXX; `endif
	\`ifndef ${1:`toupper('_'.substitute(expand('%:t'), '\.', '_', '').'_')`}
	
	\`define $1
	
	${2}
	
	\`endif // Guard
snippet package  package .. endpackage
	package ${1:package_name};
	    ${2}
	endpackage: $1
snippet parameter  parameter .. 
	parameter ${1:param_name} = ${2:param_value};
	${3}
snippet program  program .. { .. }
	program automatic ${1:name};
	    // declarations
	    ${2}
	
	    initial begin
	
	    end
	endprogram: $1
snippet randcase  randcase .. endcase
	randcase;
	    ${1:weight1}:
	        ${3}
	    ${2:weight2}:
	endcase
snippet repeat  repeat(N) ..
	repeat(${1:N}) begin
	    ${2}
	end
snippet struct  struct ... { ... }
	typedef struct {
	    ${2}
	    } ${1:name_s};
snippet task  task .. endtask
	task ${1:task_name} ($3);
	    ${2}
	endtask: $1
snippet typedef  typedef ..
	typedef ${1:type} ${2:type_name};
	${3}
snippet union  union ... { ... }
	typedef union {
	    ${2}
	} ${1:name_u};
snippet while  while() ..
	while (${1:condition}) begin
	    ${2}
	end
snippet uvmobj UVM Object Class
	class ${1:uvm_class} extends ${2:uvm_object};
	   ${3}
	   
	   \`uvm_object_utils_begin($1)
	   \`uvm_object_utils_end
	
	   extern function new(string name="$1");
	
	endclass: $1

	//-------------------------------------------------------------------------------------
	function $1::new(string name="$1");
		super.new(name);
	endfunction : new

snippet uvmcom UVM Component Class
	class ${1:uvm_class} extends ${2:uvm_component};
	   ${3}
	   
	   \`uvm_component_utils_begin($1)
	   \`uvm_component_utils_end
	
	   extern function new(string name="$1");
	
	endclass: $1

	//-------------------------------------------------------------------------------------
	function $1::new(string name="$1", uvm_component parent=null);
		super.new(name, parent);
	endfunction : new

snippet uvm UVM Object
	class ${1:uvm_class} extends ${2:uvm_object};
	   ${3}
	   
	   \`uvm_object_utils_begin($1)
	   \`uvm_object_utils_end
	
	   extern function new(string name="$1");
	
	endclass: $1

	//-------------------------------------------------------------------------------------
	function $1::new(string name="$1");
		super.new(name);
	endfunction : new

snippet uvm UVM Component
	class ${1:uvm_class} extends ${2:uvm_component};
	   ${3}
	   
	   \`uvm_component_utils_begin($1)
	   \`uvm_component_utils_end
	
	   extern function new(string name="$1");
	
	endclass: $1

	//-------------------------------------------------------------------------------------
	function $1::new(string name="$1", uvm_component parent=null);
		super.new(name, parent);
	endfunction : new

snippet new Component's New
	function ${1:class_name}::new(string name="$1", uvm_component parent=null);
		super.new(name, parent);
	endfunction : new

snippet new Object's New
	function ${1:class_name}::new(string name="$1");
		super.new(name);
	endfunction : new

snippet head Copy Right
	//=======================================================================
	// COPYRIGHT (C) 2016 Synopsys Inc.
	// This software and the associated documentation are confidential and
	// proprietary to Synopsys, Inc. Your use or disclosure of this software
	// is subject to the terms and conditions of a written license agreement
	// between you, or your company, and Synopsys, Inc. In the event of
	// publications, the following notice is applicable:
	// 
	// ALL RIGHTS RESERVED
	//
	// The entire notice above must be reproduced on all authorized copies.
	//=======================================================================
	
	\`ifndef ${1:file_name}
	\`define $1
	${2}
	\`endif  //$1

snippet add_sub_item
	add_sub_item(
		.name           ("${1}"),
		.description    ("${2}"),
		.item_type      (${3:COV_POINT})
	);
snippet begin_feature
	begin_feature (
		.name           ("${1}::${2:CG_NAME}"),
		.top_inst       ("${3}"),
		.description    ("${4}"),
		.spec_ref       (${5:$psprintf("%s -", this.spec_ref})),
		.item_type      (${6:COV_GROUP})
	);
	end_feature(); //$2
